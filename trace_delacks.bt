/*
 * Copyright 2023 Christopher Canel
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Usage:
 *     $ sudo bpftrace trace_delacks.bt
 */

#include <linux/tcp.h>
#include <net/tcp.h>
#include <net/inet_connection_sock.h>
#include <net/netns/ipv4.h>

BEGIN
{
    printf("Tracing remote port 8000. Press Ctrl-C to end...");
}

kfunc:__tcp_ack_snd_check {
    $sk = args->sk;
    $lport = $sk->__sk_common.skc_num;
    $dport = $sk->__sk_common.skc_dport;
    $dport = bswap($dport);

    if ($dport != 8000) {
        return;
    }

    printf("__tcp_ack_snd_check(sk=%u, ofo_possible=%d) local=%u->remote=%u\n",
        $sk, args->ofo_possible, $lport, $dport);

    $tp = (struct tcp_sock *) $sk;
    $icsk = (struct inet_connection_sock *) $tp;
    $icsk_ack = $icsk->icsk_ack;

    printf("\tpingpong: %u, rcv_mss: %u, ato: %u\n",
        $icsk_ack.pingpong, $icsk_ack.rcv_mss, $icsk_ack.ato);
    printf("\trcv_nxt: %u, rcv_wup: %u, rcv_nxt - rcv_wup: %u\n",
        $tp->rcv_nxt, $tp->rcv_wup, $tp->rcv_nxt - $tp->rcv_wup);
    printf("\tack_pending: %u, ICSK_ACK_NOW: %u\n",
	$icsk_ack.pending, ICSK_ACK_NOW);
}

kfunc:tcp_send_ack {
    $sk = args->sk;
    $lport = $sk->__sk_common.skc_num;
    $dport = $sk->__sk_common.skc_dport;
    $dport = bswap($dport);

    if ($dport != 8000) {
        return;
    }

    printf("tcp_send_ack(sk=%u) local=%u->remote=%u\n", $sk, $lport, $dport);
}

kfunc:tcp_delack_timer {
    printf("tcp_delack_timer()\n");
}

kfunc:tcp_delack_timer_handler {
    $sk = args->sk;
    $lport = $sk->__sk_common.skc_num;
    $dport = $sk->__sk_common.skc_dport;
    $dport = bswap($dport);

    if ($dport != 8000) {
        return;
    }

    printf("tcp_delack_timer_handler(sk=%u) local=%u->remote=%u \n", $sk, $lport, $dport);
}

kfunc:tcp_send_delayed_ack {
    $sk = args->sk;
    $lport = $sk->__sk_common.skc_num;
    $dport = $sk->__sk_common.skc_dport;
    $dport = bswap($dport);

    if ($dport != 8000) {
         return;
    }

    printf("tcp_send_delayed_ack(sk=%u) local=%u->remote=%u\n", $sk, $lport, $dport);
}
